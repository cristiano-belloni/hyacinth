<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hyacinth</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="./assets/css/bootstrap.css" rel="stylesheet">
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
    </style>
    <link href="./assets/css/bootstrap-responsive.css" rel="stylesheet">
    <link href="./assets/css/obsidian.css" rel="stylesheet">
    <link href="./assets/css/hyacinth.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../assets/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
      <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
                    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">
                                   <link rel="shortcut icon" href="../assets/ico/favicon.png">
  </head>

  <body body data-spy="scroll" data-target=".hy-docs-sidebar">

    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="#">Hyacinth</a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li><a href="hyacinth.html">Hyacinth</a></li>
              <li><a href="#host">Host</a></li>
              <li><a href="#plugins">Plugins</a></li>
              <li><a href="#alone">Standalone</a></li>
              <li class="active"><a href="#">Docs</a></li>
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contact <b class="caret"></b></a>
                <ul class="dropdown-menu">
                  <li><a href="#">Action</a></li>
                  <li><a href="#">Another action</a></li>
                  <li><a href="#">Something else here</a></li>
                  <li class="divider"></li>
                  <li class="nav-header">Nav header</li>
                  <li><a href="#">Separated link</a></li>
                  <li><a href="#">One more separated link</a></li>
                </ul>
              </li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid" id="main-container">
      <div class="row-fluid">
        <div class="span3">
          <div data-spy="affix" class="well sidebar-nav hy-docs-sidebar">
            <ul class="nav nav-list">
              <li class="nav-header">Plugin Repositories</li>
              <li class="active"><a href="#repo_structure">Structure of a plugin repository</a></li>
              <li class="nav-header">Plugin modules</li>
              <li><a href="#module_structure">Structure</a></li>
              <li><a href="#conf_object">Plugin configuration object</a></li>
              <li><a href="#constructor">The initPlugin constructor</a></li>
              <li><a href="#load_resources">Loading resources in a plugin</a></li>
              <li><a href="#main">The plugin main function</a></li>
              <li><a href="#arguments">Plugin arguments and resources</a></li>
              <li><a href="#osc">Communication with OSC</a></li>
              <li><a href="#gui">Plugin GUI</a></li>
            </ul>
          </div><!--/.well -->
        </div><!--/span-->

      <div class="span9">
      <!-- Main hero unit for a primary marketing message or call to action -->
      <div class="hero-unit">
          <img src="./assets/img/hy_logo.png">
          <div>
            <h1>Hyacinth-docs</h1>
            <hr/>
            <p>Learn about Hyacinth.</p>
          </div>
      </div>

      <hr/>

      <section id="repo_structure">
      <h2>Plugin Repositories</h2>
      
      <h3>Structure of a plugin repository</h3>

      <p>A Hyacinth collection of plugins usually is stored in a Github repository. Every plugin in a repository is contained in its subdirectory. Plugin subdirectories are located under an always-present first-level subdirectory, called <code>hy-plugins</code>.</p>

      <p>Each plugin subdirectory name corresponds to the name of the plugin. That’s how an Hyacinth host figures out the plugin name. If, for example, you are developing a plugin you want to call “Foo”, its plugin subdirectory, relative to the repository root, will be <code>/hy-plugins/Foo/</code></p>

      <p>A Hyacinth plugin is required to have a javascript module file, located under its plugin subdirectory, whose name is the plugin's name and whose extension is <code>.js</code>. So, the module file for your Foo plugin will be <code>/plugins/Foo/Foo.js</code></p>

      <p>Other files can be stored in the plugin subdirectory. Their name and location can be chosen at will, as long as they’re under your plugin subdirectory, since they have no particular meaning for the host and it will ignore them.</p>

      <p>See an example of plugin repository schema below (or take a look at the <a>standard plugin repository</a>):</p>

      <pre>
Repository root
|
+---plugins (always present)
    |
    +---Foo (plugin subdir for the Foo plugin)
    |   |
    |   +--- Foo.js (module file for Foo)
    |   |
    |   +--- assets
    |        |
    |        +---fooImage.png
    |
    +---Bar (plugin subdir for the Bar plugin)
        |
        +--- Bar.js (module file for Bar)</pre>
            
      </section>
      
      <section id="module_structure">
      <h2>Plugin modules</h2>

      <h3>Structure of a plugin module file</h3>

      <p>A Hyacinth plugin module file is a Javascript AMD module. When loaded by the host, it immediately returns an object composed by the plugin’s configuration object, called <code>pluginConf</code>, and the plugin constructor function, called <code>initPlugin</code>.</p>

      <p>Here' s an example of a bare-bones plugin module file:</p>

      <pre><code data-language="javascript">
define(['kievII', 'require'], function(k2, require) {
  /* This object is returned to the host as soon as
   * the plugin is loaded */
  var pluginConf = {
    /* ... */
  };

  /* This function is called by the host every time a plugin INSTANCE
  * is required [e.g: requested by the Add Plugin button] */
  var initPlugin = function(initArgs) {
    /* ... */
  };
            
  return {
    /* The plugin returns this object when loaded by the host */
    initPlugin: initPlugin,
    pluginConf: pluginConf
  };
});
      </code></pre>

    </section>


    <hr>



    <section id="conf_object">
    <h3>Plugin configuration object</h3>

    <pre><code data-language="javascript">
var pluginConf = {
    version: {
      major: 1,
      minor: 2,
      maintenance: 3
    },
    osc: true,   // OSC enabled
    audioIn: 4,  // Number of audio inputs
    audioOut: 1, // Number of audio outputs
    canvas: {    // Canvas real estate for the plugin
        width: 488,
        height: 164
    }
};</code></pre>

<p>pluginConf is the general plugin configuration. It describes what the host should provide to the constructor function, through the arguments, in order to create an instance of the plugin.</p>
<p>This object is loaded only once by the host. It should not change during the lifetime of the host session</p>
<p>These parameters are accepted:</p>

<table class="table table-bordered table-hover table-striped">
  <caption>pluginConf parameters</caption>
  <thead>
    <tr>
      <th> Parameter name</th>
      <th> Arguments</th>
      <th> Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>osc</code></td>
      <td>boolean</td>
      <td>If this parameter is true, the plugin is OSC-enabled. The host will pass an instance-specific OSC handler to the constructor function every time a new plugin instance is initialized.</td>
    </tr>
    <tr>
      <td><code>version</code></td>
      <td>object</td>
      <td>The plugin's version object. Version is expressed as major.minor.manteinance </td>
    </tr>
    <tr>
      <td><code>version.major</code></td>
      <td>integer ≥ 0</td>
      <td>The version's major number. Must be defined if version is defined.</td>
    </tr>
    <tr>
      <td><code>version.minor</code></td>
      <td>integer ≥ 0</td>
      <td>The version's minor number. If undefined or null, it will always be compared as lower than other defined minor numbers.</td>
    </tr>
    <tr>
      <td><code>version.maintenance</code></td>
      <td>integer ≥ 0</td>
      <td>The version's maintenance number. If undefined or null, it will always be compared as lower than other defined maintenance numbers. Can be ignored if minor is undefined or null.</td>
    </tr>
   <tr>
      <td><code>audioIn</code></td>
      <td>integer ≥ 0</td>
      <td>The number of distinct audio inputs the plugin will handle. This number <strong>doesn't</strong> represent the stereo or mono-ness of the audio inputs.</td>
    </tr>
    <tr>
      <td><code>audioOut</code></td>
      <td>integer ≥ 0</td>
      <td>The number of distinct audio outputs the plugin will handle. This number <strong>doesn't</strong> represent the stereo or mono-ness of the audio outputs.</td>
    </tr> 
    <tr>
      <td><code>canvas</code></td>
      <td>object</td>
      <td>If this object is defined, the host will create an instance-specific <a>HTML5 canvas element</a>, which will be passed to the contructor function every time a new plugin instance is initialized.</td>
    </tr> 
  </tbody>
</table>

    </section>


<section id="constructor">

  <h3>The initPlugin constructor</h3>

<pre><code data-language="javascript">
var initPlugin = function(initArgs) {
    var args = initArgs;
    var resToLoad = ['image!'+ require.toUrl('./img/myImage.png'),
                     require.toUrl('js/foo.js'),
                     'http://bar.com/bar_lib.js'];

    // Optionally load resources with require()
    require
        (resToLoad,
         function () {
             // require callback
             var resources = arguments;
             pluginFunction.call (this, args, resources);
         }.bind(this),
         function (err) {
             // require errback
             // call Host interface
             args.K2HInterface.pluginError (args.id,
                 "Error loading resources");
         }
    );
};</code></pre>
  <h4>Instance constructor</h4>

  <p><code>initPlugin</code> is the plugin constructor function. When a new plugin instance is created by the host, something along the line of var pluginInstance = new initPlugin(args) is executed. We will examine the arguments passed to this function in section TODO.
  </p>

  </section>

  <section id="load_resources">

  <h3>Loading resources</h3>

  <p>Since most plugins need to load resources before being fully operational, in this example initPlugin immediately starts to load said resources asynchronously. Requirejs is the file and module loader of choice of the <a>Hyacinth Host</a> project, so we chose to use its <code>require</code> method to load some external stuff.</p>

  <h4>Local and non-local resources</h4>

  <p>(TODO set it outside the main flow, as it deals with requirejs specific stuff) Resources can be local (relative to the plugin subdirectory URL) or non-local. To specify a local resource, we call the <code>toUrl</code> method of the require object we specified as a dependency in the initial define call (if you need to learn more about requirejs dependencies, please refer to this document).</p>

  <p>So, if we want to load a script named <code>foo.js</code>, located in the <code>js/</code> directory under the plugin subdirectory, all we have to do is to pass this parameter to require:</p>

  <pre><code data-language="javascript">require.toUrl('js/foo.js')</code></pre>

  <p>If we need to load a script located at the absolute url <code>http://bar.com/bar_lib.js</code> instead, we pass the url string directly to require:</p>

  <pre><code data-language="javascript">'http://bar.com/bar_lib.js'</code></pre>

  <h4>Other (non-script) kinds of resources</h4>

  <p>We might need to load resources that are not scripts. A plugin with a GUI might need to load some images, or some text strings, for example. You are free to write your custom loader, but KievII Host already preloads the useful Miller Medeiros’ require-js plugins. So, for instance, an easy way to load an image (or a series of images) and being notified when they’re ready is to use the image plugin. This string, passed as a parameter to the require function, will start loading the PNG image named myImage.png, located in the img directory, relative to your plugin’s subdirectory:</p>

  <pre><code data-language="javascript">'image!'+ require.toUrl('./img/myImage.png')</code></pre>

  <h4>Callbacks and errbacks</h4>

  <p>When all the resources passed to the require function are successfully loaded, a callback function is called, and you can happily start doing whatever your plugin needs to work. If the plugin requested a canvas in its pluginConf, this is the time to clear it and start drawing on it (clearing is important, because the host pre-draws a brief message on it, stating that the plugin is loading. If you want to implement your own splash screen, just clear the canvas and draw on it immediately after initPlugin is called).</p>

  <p>This callback, which we will call the success callback, is the second parameter of the require function, after the resource array. In this example, the success callback is coded like this:</p>

  <pre><code data-language="javascript">function () {
      // require callback
      var resources = arguments;
      pluginFunction.call (this, args, resources);
  }.bind(this),</code></pre>

  <p>The callback function is bound to this, since we want it to be bound to the plugin instance object initPlugin is initializing.</p>

  <p>Since the callback’s argument is the loaded resources array, we save the callback’s arguments into the resources variable. We already saved the arguments passed to the constructor (in the line var args = initArgs), so we can call the “real” plugin function, as it was a member of this, passing along the plugin arguments and the resources we just loaded.</p>

  <p>The success callback is called if all the resources load successfully. What if some of them fail to load?
    The third parameter passed to require is the so-called errback function, a callback on an error event. This is our errback:</p>

  <pre><code data-language="javascript">function (err) {
      // require errback
      // call Host interface
      args.K2HInterface.pluginError (args.id,
          "Error loading resources");
  }</code></pre>

  <p>On an error event, what we want to do is to tell the host our plugin had a non-recoverable error and can’t function properly. One side effect of this is that the host draws an error message on the plugin’s canvas, warning the user that something went wrong.
    To communicate with the plugin, we receive a K2HInterface object with the initPlugin arguments. Here, we tell the host our plugin instance (identified by args.id) had a fatal error, and set a custom message explaining what the error was.</p>

  <p>There’s a lot of things one can do, in an error event. In this case, the offending resource(s) remain defined and all the following require calls made by other future instances of the plugin will automatically fail.
    If you want the future instances of the plugin to try to re-load the resources that caused the error, you might want to undefine the offending resources.
    To obtain this, you have to find the offending resources ids and undefine them with something like requirejs.undef(failedId)</p>

  </section>

  <section id="main">
  <h3>The main plugin function</h3>

<pre><code data-language="javascript">
var pluginFunction = function (args, resources) {
    /* ... */
};
</code></pre>


  <p>A plugin function is not strictly required by the specification, but it’s good practice to separate the constructor / loader function from the real plugin definition. In the following sections, we will analyze how a plugin works (and how it can use the audio stream, the OSC handler and the canvas initialized by the host).</p>
  </section>

  <section id="arguments">
    <h3>Plugin arguments and resources</h3>

    <pre><code data-language="javascript">
// Plugin name
this.name = args.name;
// Unique id of this instance
this.id = args.id;
// get a resource loaded in initPlugin
var myImage = resources[0];</code></pre>

    <p>Each plugin instance gets an initArgs object from the host. In this example, the initPlugin constructor passes this object to the pluginFunction as the first argument, which we call args.</p>

    <p>The first arguments we will analyze are args.name and args.id. The first is the name of the plugin. It corresponds to the plugin name, as defined in the plugin subdirectory in the repository.</p>

    <p>The second is the id of this particular instance of the plugin. It is an unique id, generated by the host. Since many instances of the same plugin can coexist in the same host session, their name will be the same for any plugin of a given kind, but their id will be unique and will identify a particular instance of a given plugin.</p>

    <p>Resources are passed too, in array form (the resources array). They’re already loaded and ready to use, so you can assign them to a variable and use them as you wish.</p>

    <h3>Audio in and out nodes</h3>

<pre><code data-language="javascript">
/* Same as audioIn, audioOut */
var nOfInChannels = args.audioSources.length;
var nOfOutChannels = args.audioDestinations.length;
    
/* AudioNode arrays */
this.audioSources = args.audioSources;
this.audioDestinations = args.audioDestinations;
    
/* Main AudioContext */
this.context = args.audioContext;
</code></pre>

    <h4>Sources and destinations</h4>

    <p>The args object contains the audio sources and audio destinations of the plugin, if requested in the configuration object. Each one of these arguments, called <code>audioSources</code> and <code>audioDestinations</code>, is an array of AudioNode objects. Audio sources and destinations are created by the host every time a plugin is instantiated (so, they’re instance-specific) and they are connected automatically to other plugins’ input or output by the host, at the user’s discretion.</p>

    <p>Important: At the moment, audio sources and destinations are initialized as GainNode objects by the host. This may change in the future, so don’t assume they will always be. Plus, a well-behaved plugin must not change the gain value of its sources and destinations. If you need to apply gain, just create one or more GainNode inside your plugin and connect them to the sources / destinations.</p>

    <h4>Audio context</h4>

    <p>The audioContext attribute in the arguments object contains the main audioContext (initialized by the host). Plugins should use this context to create their nodes and to set routing between them and the source / destination nodes.
    Plugins must never connect directly to the destination node of the audioContext.</p>
    </section>

    <section id="osc">
    <h3>Sending and receiving OSC</h3>

    <pre><code data-language="javascript">
/* The OSC handler */
this.OSChandler = args.OSCHandler;
// Callback. Called when an OSC message arrives
var oscCallback = function (message) {
    console.log (this.id + " received message: ", message);
    var dest = message[0];      // osc path
    var argument1 = message[1]; // parse the message array
};

// Register the client
this.oscClient = this.OSChandler.registerClient (
    { clientID : this.id,
      oscCallback : oscCallback.bind (this) }
);
// You can send osc messages with:
var msg = new K2.OSC.Message('/path/of/outbound/message', arg1, arg2, argN);
this.oscClient.sendOSC(msg);
    </code></pre>

    
    <p>A plugin can send and receive OSC messages to and from other plugins and to and from a remote OSC-capable host in the net (using KievII’s OSCProxy server).</p>

    <p>A KievII OSCHandler object is created by the host and passed to the constructor through args.OSCHandler.</p>

    <p>The first thing a plugin will do is to obtain an oscClient object and set a callback for incoming OSC messages, calling the registerClient method of the OSCHandler.</p>

    <p>A plugin can also create an OSC message (initializing a new K2.OSC.Message object) and send that message using the sendOSC method of the previously-mentioned oscClient.</p>

    <p>OSC messages are not connected from a plugin instance to a particular other plugin instance, like audio inputs / outputs are.
        This means that when a plugin instance sends an OSCMessage with the sendOSC method, every other instance of every other plugin present in the session will receive the message. OSC messages are always broadcast.</p>

    <p>It’s likely that this behaviour will change, in the future. Until then, a plugin must filter out the messages it wants to ignore in the OSC callback.</p>

    <p>OSC is based on KievII library OSC implementation. The code is still under active developement, any contribution to improve it are accepted and encouraged.</p>
  </section>

  <section id="gui">

    <H3>Graphical interface</H3>

    <pre><code data-language="javascript">
    // KievII is already loaded
    // args.canvas is defined because pluginConf.width / height are
    this.ui = new K2.UI ({type: 'CANVAS2D', target: args.canvas});
    </code></pre>

    <p>If the canvas argument is defined in the pluginConf (along with its width and height attributes), an HTML5 canvas element will be present in args.canvas. You will need to clear the canvas before using it, since the host will pre-draw a “Loading {plugin Name}” message on it before calling the plugin constructor.
    </p>
    <p>The plugin is free to attach events to the element and draw on its context. For a quick tutorial on how to draw on canvas, take a look here.</p>

    <p>Additionally, KievII Library, an audio-app support library from yours truly, is already preloaded and ready to use. Feel free to take a look at the examples and use it to quickly set up your plugin GUI.</p>

  </section>

      <hr>

      <footer>
        <p>&copy; bitterspring.net 2013</p>
      </footer>

     </div>
    </div> <!-- /container -->

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="./assets/js/jquery-1.9.1.min.js"></script>
    <script src="./assets/js/bootstrap.min.js"></script>
    <script src="assets/js/rainbow-custom.min.js"></script>
    <!-- <script src="../assets/js/bootstrap-alert.js"></script>
    <script src="../assets/js/bootstrap-modal.js"></script>
    <script src="../assets/js/bootstrap-dropdown.js"></script>
    <script src="../assets/js/bootstrap-scrollspy.js"></script>
    <script src="../assets/js/bootstrap-tab.js"></script>
    <script src="../assets/js/bootstrap-tooltip.js"></script>
    <script src="../assets/js/bootstrap-popover.js"></script>
    <script src="../assets/js/bootstrap-button.js"></script>
    <script src="../assets/js/bootstrap-collapse.js"></script>
    <script src="../assets/js/bootstrap-carousel.js"></script>
    <script src="../assets/js/bootstrap-typeahead.js"></script> -->
  </body>
</html>
