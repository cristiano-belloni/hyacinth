<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Hyacinth</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link href="./assets/css/bootstrap.css" rel="stylesheet">
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
    </style>
    <link href="./assets/css/bootstrap-responsive.css" rel="stylesheet">
    <link href="./assets/css/obsidian.css" rel="stylesheet">
    <link href="./assets/css/hyacinth.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../assets/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
      <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
                    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">
                                   <link rel="shortcut icon" href="../assets/ico/favicon.png">
  </head>

  <body body data-spy="scroll" data-target=".hy-docs-sidebar">

    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="brand" href="#">Hyacinth</a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li><a href="hyacinth.html">Hyacinth</a></li>
              <li><a href="#host">Host</a></li>
              <li><a href="#plugins">Plugins</a></li>
              <li><a href="#alone">Standalone</a></li>
              <li class="active"><a href="#">Docs</a></li>
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contact <b class="caret"></b></a>
                <ul class="dropdown-menu">
                  <li><a href="#">Action</a></li>
                  <li><a href="#">Another action</a></li>
                  <li><a href="#">Something else here</a></li>
                  <li class="divider"></li>
                  <li class="nav-header">Nav header</li>
                  <li><a href="#">Separated link</a></li>
                  <li><a href="#">One more separated link</a></li>
                </ul>
              </li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid" id="main-container">
      <div class="row-fluid">
        <div class="span3">
          <div data-spy="affix" class="well sidebar-nav hy-docs-sidebar">
            <ul class="nav nav-list">
              <li class="nav-header">Plugin Repositories</li>
              <li class="active"><a href="#repo_structure">Structure of a plugin repository</a></li>
              <li class="nav-header">Plugin modules</li>
              <li><a href="#module_structure">Structure</a></li>
              <li><a href="#conf_object">The pluginConf configuration object</a></li>
              <li><a href="#constructor">The initPlugin constructor</a></li>
              <li><a href="#plugin_state">Plugin State</a></li>
              <li><a href="#host_interface">Interfacing with the Host</a></li>
              <li><a href="#load_resources">Digression: Loading resources</a></li>
              <li><a href="#main">Main plugin function</a></li>
              <li><a href="#arguments">Plugin arguments</a></li>
              <li><a href="#osc">Communication with OSC</a></li>
              <li><a href="#gui">Plugin GUI</a></li>
            </ul>
          </div><!--/.well -->
        </div><!--/span-->

      <div class="span9">
      <!-- Main hero unit for a primary marketing message or call to action -->
      <div class="hero-unit">
          <img src="./assets/img/hy_logo.png">
          <div>
            <h1>Hyacinth-docs</h1>
            <hr/>
            <p>Learn about Hyacinth.</p>
          </div>
      </div>

      <hr/>

      <section id="repo_structure">
      <h2>Plugin Repositories</h2>
      
      <h3>Structure of a plugin repository</h3>

      <p>A Hyacinth collection of plugins usually is stored in a Github repository. Every plugin in a repository is contained in its subdirectory. Plugin subdirectories are located under an always-present first-level subdirectory, called <code>hy-plugins</code>.</p>

      <p>Each plugin subdirectory name corresponds to the name of the plugin. That’s how an Hyacinth host figures out the plugin name. If, for example, you are developing a plugin you want to call “Foo”, its plugin subdirectory, relative to the repository root, will be <code>/hy-plugins/Foo/</code></p>

      <p>A Hyacinth plugin is required to have a javascript module file, located under its plugin subdirectory, whose name is the plugin's name and whose extension is <code>.js</code>. So, the module file for your Foo plugin will be <code>/plugins/Foo/Foo.js</code></p>

      <p>Other files can be stored in the plugin subdirectory. Their name and location can be chosen at will, as long as they’re under your plugin subdirectory, since they have no particular meaning for the host and it will ignore them.</p>

      <p>See an example of plugin repository schema below (or take a look at the <a>standard plugin repository</a>):</p>

      <pre>
Repository root
|
+---hy-plugins (always present)
    |
    +---Foo (plugin subdir for the Foo plugin)
    |   |
    |   +--- Foo.js (module file for Foo)
    |   |
    |   +--- assets
    |        |
    |        +---fooImage.png
    |
    +---Bar (plugin subdir for the Bar plugin)
        |
        +--- Bar.js (module file for Bar)</pre>
            
      </section>
      
      <section id="module_structure">
      <h2>Plugin modules</h2>

      <h3>Structure of a plugin module file</h3>

      <p>A Hyacinth plugin module file is a Javascript AMD module. When loaded by the host, it immediately returns an object composed by the plugin’s configuration object, called <code>pluginConf</code>, and the plugin constructor function, called <code>initPlugin</code>.</p>

      <p>Here' s an example of a bare-bones plugin module file:</p>

      <pre><code data-language="javascript">
define(['kievII', 'require'], function(k2, require) {
  /* This object is returned to the host as soon as
   * the plugin is loaded */
  var pluginConf = {
    /* ... */
  };

  /* This function is called by the host every time a plugin INSTANCE
  * is required [e.g: requested by the Add Plugin button] */
  var initPlugin = function(initArgs) {
    /* ... */
  };
            
  return {
    /* The plugin returns this object when loaded by the host */
    initPlugin: initPlugin,
    pluginConf: pluginConf
  };
});
      </code></pre>

    </section>


    <hr>



    <section id="conf_object">
    <h3>the pluginConf configuration object</h3>

    <pre><code data-language="javascript">
var pluginConf = {
    version: {
      major: 1,
      minor: 2,
      maintenance: 3
    },
    osc: true,   // OSC enabled
    audioIn: 4,  // Number of audio inputs
    audioOut: 1, // Number of audio outputs
    canvas: {    // Canvas real estate for the plugin
        width: 488,
        height: 164
    }
};</code></pre>

<p><code>pluginConf</code> is the plugin configuration object. It describes what the host should provide to the constructor function, through the arguments, in order to create an instance of the plugin.</p>
<p>This object is evaluated only once by the host, at plugin load. It should not change during the lifetime of the host session.</p>
<p><code>pluginConf</code> accepts these parameters:</p>

<table class="table table-bordered table-hover table-striped">
  <caption>pluginConf parameters</caption>
  <thead>
    <tr>
      <th> Parameter name</th>
      <th> Arguments</th>
      <th> Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>osc</code></td>
      <td>boolean</td>
      <td>If this parameter is true, the plugin is OSC-enabled. The host will pass an instance-specific OSC handler to the constructor function every time a new plugin instance is initialized.</td>
    </tr>
    <tr>
      <td><code>version</code></td>
      <td>object</td>
      <td>The plugin's version object. Version is expressed as <em>major.minor.patch</em></td>
    </tr>
    <tr>
      <td><code>version.major</code></td>
      <td>integer ≥ 0</td>
      <td>The version's major number. Must be defined if version is defined.</td>
    </tr>
    <tr>
      <td><code>version.minor</code></td>
      <td>integer ≥ 0</td>
      <td>The version's minor number. If undefined or null, it will always be compared as lower than other defined minor numbers.</td>
    </tr>
    <tr>
      <td><code>version.patch</code></td>
      <td>integer ≥ 0</td>
      <td>The version's patch number. If undefined or null, it will always be compared as lower than other defined patch numbers. Can be ignored by the host if minor is undefined or null.</td>
    </tr>
    <tr>
      <td><code>version.desc</code></td>
      <td>string</td>
      <td>A human-readable (string) description of the version. Can be a codename or a brief description. Has no influence on comparing versions.</td>
    </tr>
   <tr>
      <td><code>audioIn</code></td>
      <td>integer ≥ 0</td>
      <td>The number of distinct audio inputs the plugin will handle. This number <strong>doesn't</strong> represent the stereo or mono-ness of the audio inputs.</td>
    </tr>
    <tr>
      <td><code>audioOut</code></td>
      <td>integer ≥ 0</td>
      <td>The number of distinct audio outputs the plugin will handle. This number <strong>doesn't</strong> represent the stereo or mono-ness of the audio outputs.</td>
    </tr> 
    <tr>
      <td><code>canvas</code></td>
      <td>object</td>
      <td>If this object is defined, the host will create an instance-specific <a>HTML5 canvas element</a>, which will be passed to the contructor function every time a new plugin instance is initialized. Incompatible with the <code>div</code> option.</td>
    </tr>
    <tr>
      <td><code>canvas.width</code></td>
      <td>integer ≥ 0</td>
      <td>Canvas width. Mandatory if <code>canvas</code> object is defined.</td>
    </tr>
    <tr>
      <td><code>canvas.height</code></td>
      <td>integer ≥ 0</td>
      <td>Canvas height. Mandatory if <code>canvas</code> object is defined.</td>
    </tr>
    <tr>
      <td><code>div</code></td>
      <td>object</td>
      <td>If this object is defined, the host will create an instance-specific <a>div</a>, which will be passed to the contructor function every time a new plugin instance is initialized. Incompatible with the <code>canvas</code> option.</td>
    </tr>
    <tr>
      <td><code>div.width</code></td>
      <td>integer ≥ 0</td>
      <td>Div width. Mandatory if <code>div</code> object is defined.</td>
    </tr>
    <tr>
      <td><code>div.height</code></td>
      <td>integer ≥ 0</td>
      <td>Div height. Mandatory if <code>div</code> object is defined.</td>
    </tr> 
  </tbody>
</table>

    </section>


<section id="constructor">

  <h3>The initPlugin constructor</h3>

<pre><code data-language="javascript">
var initPlugin = function(initArgs) {
    /*  Process the arguments
        [...]
    */

    /*  Load resources
        [...]
    */

    if (fatalError) {
      /*  Cleanup code
          [...]
      */

      /* Fatal error occurred: set the state in HyInterface */
      args.HyInterface.setInstanceState ('fatal', {description: errorMsg});
      return;
    }

    /* Plugin is ready */
    args.HyInterface.setInstanceState ('ready');

};</code></pre>

  <p><code>initPlugin</code> is the plugin constructor function. When a new plugin instance is created by the host, something along the line of <code>var pluginInstance = new initPlugin(args)</code> is executed. This function is responsible of creating a <em>plugin instance</em>. This includes loading resources, when needed, initializing the plugin, and changing the state of the plugin when the initialization phase is over (see the <a href="#plugin_state">Plugin State section</a>)</p>
  <p>We will examine the arguments passed to this function later, in the <a href="#arguments">Plugin Arguments section</a>.
  </p>

  </section>

  <section id="plugin_state">

    <h3>Plugin State</h3>

    <p>Every plugin instance, in its lifetime, has a state, assigned at init-time by the host. Everytime a plugin changes state, the host is notified via the <a href="#host_interface">Host Interface</a> mechanism. The possible states of a plugin are listed in the following table:
    </p>

    <table class="table table-bordered table-hover table-striped">
      <caption>plugin instance states</caption>
      <thead>
        <tr>
          <th> State</th>
          <th> Meaning</th>
          <th> Behaviour</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>init</code></td>
          <td>The plugin instance is non-functional because it is initializing or loading resources. It can became functional later.</td>
          <td>This is the default state on plugin creation. The plugin is not functional, awaiting for its initialization tasks to complete. This is a temporary state, which will be changed as soon the initialization is complete or a fatal error is encountered. The host can display a temporary message warning the user that the plugin is being initialized.</td>
        </tr>
        <tr>
          <td><code>fatal</code></td>
          <td>The plugin instance is non-functional because it encountered a non-recoverable error. The plugin instance will never be functional.</td>
          <td>This state is the fatal error state. The plugin instance encountered an un-recoverable error during its initialization or at run time. This is a "terminal" state, which should never be changed again by the plugin instance. The host can display a message warning the user that the plugin instance is in an error state, or destroy the plugin object right away.</td>
        </tr>
        <tr>
          <td><code>ready</code></td>
          <td>The plugin instance is functional and ready to be used.</td>
          <td>After completing initialization, and having not encountered a fatal error, a plugin instance signals that it is in the ready state. The plugin is functional and ready to be used. This state can change to the fatal state if a fatal error is encountered, or back to the init state if the plugin needs to perform offline operations that would put it in a non-functional state (loading additional resources, or a long non-real-time calculation, for example).</td>
        </tr>
      </tbody>
    </table>

  </section>

  <section id="host_interface">
    <h3>Interfacing with the Host</h3>
    <p>
      A plugin instance can communicate with the host, to notify a change on its <a href="plugin_states">state</a> or to get informations about other plugins.
    </p>
    <p>
      An interface object is passed in the arguments (read more about the arguments passed to a plugin instance in the <a href="#arguments">Plugin Arguments section</a>). The object exposes these functions:
    </p>

    <dl>
      <dt><h4>setInstanceState</h4></dt>
      <dd><h5>Parameters</h5> <code><em>string</em> state, <em>object</em> options</code></dd>
      <dd><h5>Return value</h5> <em>none</em></dd>
      <dd><h5>Description</h5> <p>Set the instance state, as described in <a href="#plugin_state">this section</a>. Accepted values for the parameter a re <code>init</code>, <code>fatal</code> and <code>ready</code>. If <code>state === 'fatal'</code>, <code>options.description</code> can be specified to provide a description for the fatal event.</p></dd>
    </dl>


    <dl>
      <dt><h4>getOSCInstances</h4></dt>
      <dd><h5>Parameters</h5> <em>none</em></dd>
      <dd><h5>Return value</h5> an <code>Array</code> of OSC-enabled <code>pluginInstanceDesc</code>, where <code>pluginInstanceDesc.id</code> is the unique id of the instance, <code>pluginInstanceDesc.pluginName</code> is the instance's plugin name and <code>pluginInstanceDesc.pluginCustomName</code> is the instance's custom name (if the host doesn't support user-defined instance names, this is equal to <code>pluginInstanceDesc.pluginName</code>.</dd>
      <dd><h5>Description</h5> <p>Get a list of OSC-enabled plugin instances present in the current session. A plugin instance can request such a list for OSC discovery. By convention, the host should return only instances in their <code>ready</code> state. The field <code>pluginInstanceDesc.pluginCustomName</code> can be specified if the host supports custom (user-defined) names for instances. Otherwise, it should be equal to <code>pluginInstanceDesc.pluginName</code>. <code>pluginInstanceDesc.id</code> is an id, generated by the host, that uniquely identifies a given plugin instance.</p></dd>
    </dl>

  </section>


  <section id="load_resources">

  <h3>Initializing and loading resources</h3>

  <p>Since most plugins need to load resources, such as images, impulse files or other scripts before being fully operational, the constructor is the place where to load resources asynchronously.</p>

  <p>A plugin can load its resources anyway it likes. In these examples the <a>Requirejs</a> library, along with the <a>requirejs-plugins</a> modules is used to load additional images and scripts. Additionally, the <a>Hyacinth Host</a> project includes Requirejs and requirejs-plugins, so a plugin can start using them right away.</p>

  <h4>Example Local and non-local resources with Require</h4>

  <p><em>TODO head-up This is not a guide to Requirejs: if you want to learn Requirejs, please refer to <a>their documentation</a></em> Resources can be local (relative to the plugin subdirectory URL) or non-local. To specify a local resource, we call the <code>toUrl</code> method of the require object we specified as a dependency in the initial define call.</p>

  <p>So, if we want to load a script named <code>foo.js</code>, located in the <code>js/</code> directory under the plugin subdirectory, all we have to do is to pass this parameter to require:</p>

  <pre><code data-language="javascript">require.toUrl('js/foo.js')</code></pre>

  <p>If we need to load a script located at the absolute url <code>http://bar.com/bar_lib.js</code> instead, we pass the url string directly to require:</p>

  <pre><code data-language="javascript">'http://bar.com/bar_lib.js'</code></pre>

  <h4>Other (non-script) kinds of resources</h4>

  <p>We might need to load resources that are not scripts. A plugin with a GUI might need to load some images, or some text strings, for example. You are free to write your custom loader, of course. In these examples, we're going to use some of <a>Miller Medeiros’ require-js</a> plugins. So, for instance, an easy way to load an image (or a series of images) and being notified when they’re ready is to use the image plugin. This string, passed as a parameter to the require function, will start loading the PNG image named myImage.png, located in the img directory, relative to your plugin’s subdirectory:</p>

  <pre><code data-language="javascript">'image!'+ require.toUrl('./img/myImage.png')</code></pre>

  <h4>Callbacks and errbacks</h4>

  <p>When all the resources passed to the require function are successfully loaded, a callback function is called, and you can happily start doing whatever your plugin needs to work. If the plugin requested a canvas in its pluginConf, this is the time to clear it and start drawing on it (clearing is important, because the host pre-draws a brief message on it, stating that the plugin is loading. If you want to implement your own splash screen, just clear the canvas and draw on it immediately after initPlugin is called).</p>

  <p>This callback, which we will call the success callback, is the second parameter of the require function, after the resource array. In this example, the success callback is coded like this:</p>

  <pre><code data-language="javascript">function () {
      // require callback
      var resources = arguments;
      pluginFunction.call (this, args, resources);
  }.bind(this),</code></pre>

  <p>The callback function is bound to this, since we want it to be bound to the plugin instance object initPlugin is initializing.</p>

  <p>Since the callback’s argument is the loaded resources array, we save the callback’s arguments into the resources variable. We already saved the arguments passed to the constructor (in the line var args = initArgs), so we can call the “real” plugin function, as it was a member of this, passing along the plugin arguments and the resources we just loaded.</p>

  <p>The success callback is called if all the resources load successfully. What if some of them fail to load?
    The third parameter passed to require is the so-called errback function, a callback on an error event. This is our errback:</p>

  <pre><code data-language="javascript">function (err) {
      // require errback
      // call Host interface
      args.K2HInterface.pluginError (args.id,
          "Error loading resources");
  }</code></pre>

  <p>On an error event, what we want to do is to tell the host our plugin had a non-recoverable error and can’t function properly. One side effect of this is that the host draws an error message on the plugin’s canvas, warning the user that something went wrong.
    To communicate with the plugin, we receive a K2HInterface object with the initPlugin arguments. Here, we tell the host our plugin instance (identified by args.id) had a fatal error, and set a custom message explaining what the error was.</p>

  <p>There’s a lot of things one can do, in an error event. In this case, the offending resource(s) remain defined and all the following require calls made by other future instances of the plugin will automatically fail.
    If you want the future instances of the plugin to try to re-load the resources that caused the error, you might want to undefine the offending resources.
    To obtain this, you have to find the offending resources ids and undefine them with something like requirejs.undef(failedId)</p>

  </section>

  <section id="main">
  <h3>The main plugin function</h3>

<pre><code data-language="javascript">
var pluginFunction = function (args, resources) {
    /* ... */
};
</code></pre>


  <p>A plugin function is not strictly required by the specification, but it’s good practice to separate the constructor / loader function from the real plugin definition. In the following sections, we will analyze how a plugin works (and how it can use the audio stream, the OSC handler and the canvas initialized by the host).</p>
  </section>

  <section id="arguments">
    <h3>Plugin arguments and resources</h3>

    <pre><code data-language="javascript">
// Plugin name
this.name = args.name;
// Unique id of this instance
this.id = args.id;
// get a resource loaded in initPlugin
var myImage = resources[0];</code></pre>

    <p>Each plugin instance gets an initArgs object from the host. In this example, the initPlugin constructor passes this object to the pluginFunction as the first argument, which we call args.</p>

    <p>The first arguments we will analyze are args.name and args.id. The first is the name of the plugin. It corresponds to the plugin name, as defined in the plugin subdirectory in the repository.</p>

    <p>The second is the id of this particular instance of the plugin. It is an unique id, generated by the host. Since many instances of the same plugin can coexist in the same host session, their name will be the same for any plugin of a given kind, but their id will be unique and will identify a particular instance of a given plugin.</p>

    <p>Resources are passed too, in array form (the resources array). They’re already loaded and ready to use, so you can assign them to a variable and use them as you wish.</p>

    <h3>Audio in and out nodes</h3>

<pre><code data-language="javascript">
/* Same as audioIn, audioOut */
var nOfInChannels = args.audioSources.length;
var nOfOutChannels = args.audioDestinations.length;
    
/* AudioNode arrays */
this.audioSources = args.audioSources;
this.audioDestinations = args.audioDestinations;
    
/* Main AudioContext */
this.context = args.audioContext;
</code></pre>

    <h4>Sources and destinations</h4>

    <p>The args object contains the audio sources and audio destinations of the plugin, if requested in the configuration object. Each one of these arguments, called <code>audioSources</code> and <code>audioDestinations</code>, is an array of AudioNode objects. Audio sources and destinations are created by the host every time a plugin is instantiated (so, they’re instance-specific) and they are connected automatically to other plugins’ input or output by the host, at the user’s discretion.</p>

    <p>Important: At the moment, audio sources and destinations are initialized as GainNode objects by the host. This may change in the future, so don’t assume they will always be. Plus, a well-behaved plugin must not change the gain value of its sources and destinations. If you need to apply gain, just create one or more GainNode inside your plugin and connect them to the sources / destinations.</p>

    <h4>Audio context</h4>

    <p>The audioContext attribute in the arguments object contains the main audioContext (initialized by the host). Plugins should use this context to create their nodes and to set routing between them and the source / destination nodes.
    Plugins must never connect directly to the destination node of the audioContext.</p>
    </section>

    <section id="osc">
    <h3>Sending and receiving OSC</h3>

    <pre><code data-language="javascript">
/* The OSC handler */
this.OSChandler = args.OSCHandler;
// Callback. Called when an OSC message arrives
var oscCallback = function (message) {
    console.log (this.id + " received message: ", message);
    var dest = message[0];      // osc path
    var argument1 = message[1]; // parse the message array
};

// Register the client
this.oscClient = this.OSChandler.registerClient (
    { clientID : this.id,
      oscCallback : oscCallback.bind (this) }
);
// You can send osc messages with:
var msg = new K2.OSC.Message('/path/of/outbound/message', arg1, arg2, argN);
this.oscClient.sendOSC(msg);
    </code></pre>

    
    <p>A plugin can send and receive OSC messages to and from other plugins and to and from a remote OSC-capable host in the net (using KievII’s OSCProxy server).</p>

    <p>A KievII OSCHandler object is created by the host and passed to the constructor through args.OSCHandler.</p>

    <p>The first thing a plugin will do is to obtain an oscClient object and set a callback for incoming OSC messages, calling the registerClient method of the OSCHandler.</p>

    <p>A plugin can also create an OSC message (initializing a new K2.OSC.Message object) and send that message using the sendOSC method of the previously-mentioned oscClient.</p>

    <p>OSC messages are not connected from a plugin instance to a particular other plugin instance, like audio inputs / outputs are.
        This means that when a plugin instance sends an OSCMessage with the sendOSC method, every other instance of every other plugin present in the session will receive the message. OSC messages are always broadcast.</p>

    <p>It’s likely that this behaviour will change, in the future. Until then, a plugin must filter out the messages it wants to ignore in the OSC callback.</p>

    <p>OSC is based on KievII library OSC implementation. The code is still under active developement, any contribution to improve it are accepted and encouraged.</p>
  </section>

  <section id="gui">

    <H3>Graphical interface</H3>

    <pre><code data-language="javascript">
    // KievII is already loaded
    // args.canvas is defined because pluginConf.width / height are
    this.ui = new K2.UI ({type: 'CANVAS2D', target: args.canvas});
    </code></pre>

    <p>If the canvas argument is defined in the pluginConf (along with its width and height attributes), an HTML5 canvas element will be present in args.canvas. You will need to clear the canvas before using it, since the host will pre-draw a “Loading {plugin Name}” message on it before calling the plugin constructor.
    </p>
    <p>The plugin is free to attach events to the element and draw on its context. For a quick tutorial on how to draw on canvas, take a look here.</p>

    <p>Additionally, KievII Library, an audio-app support library from yours truly, is already preloaded and ready to use. Feel free to take a look at the examples and use it to quickly set up your plugin GUI.</p>

  </section>

      <hr>

      <footer>
        <p>&copy; bitterspring.net 2013</p>
      </footer>

     </div>
    </div> <!-- /container -->

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="./assets/js/jquery-1.9.1.min.js"></script>
    <script src="./assets/js/bootstrap.min.js"></script>
    <script src="assets/js/rainbow-custom.min.js"></script>
    <!-- <script src="../assets/js/bootstrap-alert.js"></script>
    <script src="../assets/js/bootstrap-modal.js"></script>
    <script src="../assets/js/bootstrap-dropdown.js"></script>
    <script src="../assets/js/bootstrap-scrollspy.js"></script>
    <script src="../assets/js/bootstrap-tab.js"></script>
    <script src="../assets/js/bootstrap-tooltip.js"></script>
    <script src="../assets/js/bootstrap-popover.js"></script>
    <script src="../assets/js/bootstrap-button.js"></script>
    <script src="../assets/js/bootstrap-collapse.js"></script>
    <script src="../assets/js/bootstrap-carousel.js"></script>
    <script src="../assets/js/bootstrap-typeahead.js"></script> -->
  </body>
</html>
